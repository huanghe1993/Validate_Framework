## 场景设计

实际的生产场景是笔者负责的某个系统需要对接一个外部的资金方，每一笔资金下单后需要延时30分钟推送对应的附件。
这里简化为一个订单信息数据延迟处理的场景，就是每一笔下单记录一条订单消息(暂时叫做`OrderMessage`)，订单消息需要延迟5到15秒后进行异步处理。

## 候选方案对比

下面是想到的几种实现延时任务的方案，总结了一下相应的优势和劣势。

|                        方案                        |        优势        |                         劣势                         |           选用场景           |
| :------------------------------------------------: | :----------------: | :--------------------------------------------------: | :--------------------------: |
|          `JDK`内置的延迟队列`DelayQueue`           |      实现简单      |                  数据内存态，不可靠                  |      一致性相对低的场景      |
|          调度框架和`MySQL`进行短间隔轮询           | 实现简单，可靠性高 |                  存在明显的性能瓶颈                  | 数据量较少实时性相对低的场景 |
| `RabbitMQ`的`DLX`和`TTL`，一般称为**死信队列**方案 |  异步交互可以削峰  | 延时的时间长度不可控，如果数据需要持久化则性能会降低 |              -               |
|          调度框架和`Redis`进行短间隔轮询           | 数据持久化，高性能 |                      实现难度大                      |  **常见于支付结果回调方案**  |
|                       时间轮                       |      实时性高      |                实现难度大，内存消耗大                |        实时性高的场景        |

如果应用的数据量不高，实时性要求比较低，选用调度框架和`MySQL`进行短间隔轮询这个方案是最优的方案。但是笔者遇到的场景数据量相对比较大，实时性并不高，采用扫库的方案一定会对`MySQL`实例造成比较大的压力。记得很早之前，看过一个PPT叫《盒子科技聚合支付系统演进》，其中里面有一张图片给予笔者一点启发：

最终选用了基于`Redis`的有序集合`Sorted Set`和`Quartz`短轮询进行实现。具体方案是：

1. 订单创建的时候，订单ID和当前时间戳分别作为`Sorted Set`的member和score添加到订单队列`Sorted Set`中。
2. 订单创建的时候，订单ID和推送内容`JSON`字符串分别作为field和value添加到订单队列内容`Hash`中。
3. 第1步和第2步操作的时候用`Lua`脚本保证原子性。
4. 使用一个异步线程通过`Sorted Set`的命令`ZREVRANGEBYSCORE`弹出指定数量的订单ID对应的订单队列内容`Hash`中的订单推送内容数据进行处理。
